#define BOOST_TEST_MODULE stringtest
#include <boost/test/included/unit_test.hpp>
#include "unittesting.h"

BOOST_AUTO_TEST_SUITE (equality_test)

BOOST_AUTO_TEST_CASE (monomial_self_equality) {
  vector<int> d;
  d.push_back(2);
	Interval I(1);
	Monomial m(I, d);
  BOOST_REQUIRE_EQUAL (m.equals(m), 0);
}

BOOST_AUTO_TEST_CASE (monomial_equality) {
  vector<int> d1;
  d1.push_back(1);
	Interval I1(1);
	Monomial m1(I1, d1);
  
  vector<int> d2;
  d2.push_back(1);
	Interval I2(1);
	Monomial m2(I2, d2);
  BOOST_REQUIRE_EQUAL (m1.equals(m2), 0);
}

BOOST_AUTO_TEST_CASE (monomial_inequality_sizes) {
  vector<int> d1;
  d1.push_back(1);
	Interval I1(1);
	Monomial m1(I1, d1);
  
  vector<int> d2;
  d2.push_back(1);
  d2.push_back(1);
	Interval I2(1);
	Monomial m2(I2, d2);
  int r = m1.equals(m2);
  
  BOOST_CHECK_PREDICATE( std::not_equal_to<int>(), (r)(0) ); 
}

BOOST_AUTO_TEST_CASE (monomial_inequality_degrees) {
  vector<int> d1;
  d1.push_back(1);
  d1.push_back(1);
  d1.push_back(1);
	Interval I1(1);
	Monomial m1(I1, d1);
  
  vector<int> d2;
  d2.push_back(1);
  d2.push_back(1);
  d2.push_back(2);
	Interval I2(1);
	Monomial m2(I2, d2);
  int r = m1.equals(m2);
  
  BOOST_CHECK_PREDICATE( std::not_equal_to<int>(), (r)(0) ); 
}


BOOST_AUTO_TEST_CASE (monomial_transform) {
  vector<int> d1;
  d1.push_back(0);
  d1.push_back(0);
  d1.push_back(1);
	Interval I1(1);
	Monomial m1(I1, d1);
  
  vector<int> d2;
  d2.push_back(0);
  d2.push_back(1);
	Interval I2(1);
	Monomial m2(I2, d2);
  
  
  vector<int> map;
  map.push_back(1);
  Monomial m3 = m1.transform(map);  
  
  int r = m2.equals(m3);
  BOOST_REQUIRE_EQUAL (r, 0);
}


BOOST_AUTO_TEST_CASE (monomial_padding_transform) {
  vector<int> d1;
  d1.push_back(1);
  d1.push_back(2);
  d1.push_back(3);
	Interval I1(1);
	Monomial m1(I1, d1);
  
  vector<int> d2;
  d2.push_back(1);
  d2.push_back(0);
  d2.push_back(2);
  d2.push_back(0);
  d2.push_back(3);
  d2.push_back(0);
	Interval I2(1);
	Monomial m2(I2, d2);
  
  
  vector<int> map;
  map.push_back(PADDING_VARIABLE);
  map.push_back(0);
  map.push_back(PADDING_VARIABLE);
  map.push_back(1);
  map.push_back(PADDING_VARIABLE);
  Monomial m3 = m1.transform(map);  
  int r = m2.equals(m3);
  BOOST_REQUIRE_EQUAL (r, 0);
}

BOOST_AUTO_TEST_CASE (monomial_transform_exception) {
  vector<int> d1;
  d1.push_back(0);
  d1.push_back(0);
  d1.push_back(1);
	Interval I1(1);
	Monomial m1(I1, d1);
  
  vector<int> d2;
  d2.push_back(0);
  d2.push_back(1);
	Interval I2(1);
	Monomial m2(I2, d2);
  
  
  vector<int> map;
  map.push_back(0);
  
  try {
    Monomial m3 = m1.transform(map);
    BOOST_REQUIRE_EQUAL ("no exception", "");
  } catch (const std::invalid_argument& e) {
  }
}

BOOST_AUTO_TEST_CASE (subcomponent_transformation) {
  MyComponent c1 = MyComponent();
  c1.varIndexes.push_back(0);
  c1.varIndexes.push_back(3);
  c1.varIndexes.push_back(5);
  MyComponent c2 = MyComponent();
  c2.varIndexes.push_back(2);
  c2.varIndexes.push_back(4);
  c2.varIndexes.push_back(5);
  c2.varIndexes.push_back(6);
  MyComponent c = MyComponent();
  c.previous.push_back(c1);
  c.previous.push_back(c2);
  vector< vector<int> > mappers = c.previousMappers();
  vector< vector<int> > expected;
  vector<int> e1;
  vector<int> e2;
  e1.push_back(0);
  e1.push_back(-2);
  e1.push_back(1);
  e1.push_back(-2);
  e1.push_back(2);
  e1.push_back(-2);
  
  e2.push_back(-2);
  e2.push_back(0);
  e2.push_back(-2);
  e2.push_back(1);
  e2.push_back(2);
  e2.push_back(3);
  expected.push_back(e1);
  expected.push_back(e2);
  
  BOOST_REQUIRE_EQUAL(expected.size(), mappers.size());
  for(int i = 0; i < expected.size(); i++) {
    vector<int> v1 = expected.at(i);
    vector<int> v2 = mappers.at(i);
    BOOST_REQUIRE_EQUAL(v1.size(), v2.size());
    BOOST_REQUIRE_EQUAL(true, equal(v1.begin(), v1.end(), v2.begin()));
  }
}

BOOST_AUTO_TEST_SUITE_END( )
